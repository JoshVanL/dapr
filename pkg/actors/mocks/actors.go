// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	context "context"
	"errors"


	mock "github.com/stretchr/testify/mock"


	      invokev1 "github.com/dapr/dapr/pkg/messaging/v1"
	actors "github.com/dapr/dapr/pkg/actors"
       daprt "github.com/dapr/dapr/pkg/testing"
	v1 "github.com/dapr/dapr/pkg/messaging/v1"
)

// Actors is an autogenerated mock type for the Actors type
type Actors struct {
	mock.Mock
}

// Call provides a mock function with given fields: ctx, req
func (_m *Actors) Call(ctx context.Context, req *v1.InvokeMethodRequest) (*v1.InvokeMethodResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *v1.InvokeMethodResponse
	if rf, ok := ret.Get(0).(func(context.Context, *v1.InvokeMethodRequest) *v1.InvokeMethodResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.InvokeMethodResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *v1.InvokeMethodRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReminder provides a mock function with given fields: ctx, req
func (_m *Actors) CreateReminder(ctx context.Context, req *actors.CreateReminderRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *actors.CreateReminderRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTimer provides a mock function with given fields: ctx, req
func (_m *Actors) CreateTimer(ctx context.Context, req *actors.CreateTimerRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *actors.CreateTimerRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteReminder provides a mock function with given fields: ctx, req
func (_m *Actors) DeleteReminder(ctx context.Context, req *actors.DeleteReminderRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *actors.DeleteReminderRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTimer provides a mock function with given fields: ctx, req
func (_m *Actors) DeleteTimer(ctx context.Context, req *actors.DeleteTimerRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *actors.DeleteTimerRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetActiveActorsCount provides a mock function with given fields: ctx
func (_m *Actors) GetActiveActorsCount(ctx context.Context) []actors.ActiveActorsCount {
	ret := _m.Called(ctx)

	var r0 []actors.ActiveActorsCount
	if rf, ok := ret.Get(0).(func(context.Context) []actors.ActiveActorsCount); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]actors.ActiveActorsCount)
		}
	}

	return r0
}

// GetReminder provides a mock function with given fields: ctx, req
func (_m *Actors) GetReminder(ctx context.Context, req *actors.GetReminderRequest) (*actors.Reminder, error) {
	ret := _m.Called(ctx, req)

	var r0 *actors.Reminder
	if rf, ok := ret.Get(0).(func(context.Context, *actors.GetReminderRequest) *actors.Reminder); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*actors.Reminder)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *actors.GetReminderRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetState provides a mock function with given fields: ctx, req
func (_m *Actors) GetState(ctx context.Context, req *actors.GetStateRequest) (*actors.StateResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *actors.StateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *actors.GetStateRequest) *actors.StateResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*actors.StateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *actors.GetStateRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Init provides a mock function with given fields: _a0
func (_m *Actors) Init(_a0 context.Context) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsActorHosted provides a mock function with given fields: ctx, req
func (_m *Actors) IsActorHosted(ctx context.Context, req *actors.ActorHostedRequest) bool {
	ret := _m.Called(ctx, req)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, *actors.ActorHostedRequest) bool); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RenameReminder provides a mock function with given fields: ctx, req
func (_m *Actors) RenameReminder(ctx context.Context, req *actors.RenameReminderRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *actors.RenameReminderRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with given fields:
func (_m *Actors) Stop() {
	_m.Called()
}

// TransactionalStateOperation provides a mock function with given fields: ctx, req
func (_m *Actors) TransactionalStateOperation(ctx context.Context, req *actors.TransactionalRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *actors.TransactionalRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewActors interface {
	mock.TestingT
	Cleanup(func())
}

// NewActors creates a new instance of Actors. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewActors(t mockConstructorTestingTNewActors) *Actors {
	mock := &Actors{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

type FailingActors struct {
       Failure daprt.Failure
}

func (f *FailingActors) Call(ctx context.Context, req *invokev1.InvokeMethodRequest) (*invokev1.InvokeMethodResponse, error) {
       proto, err := req.ProtoWithData()
       if err != nil {
               return nil, err
       }
       if proto == nil || proto.Actor == nil {
               return nil, errors.New("proto.Actor is nil")
       }
       if err := f.Failure.PerformFailure(proto.Actor.ActorId); err != nil {
               return nil, err
       }
       var data []byte
       if proto.Message != nil && proto.Message.Data != nil {
               data = proto.Message.Data.Value
       }
       resp := invokev1.NewInvokeMethodResponse(200, "Success", nil).
               WithRawDataBytes(data)
       return resp, nil
}

func (f *FailingActors) Init(ctx context.Context, ) error {
       return nil
}

func (f *FailingActors) Stop() {
}

func (f *FailingActors) GetState(ctx context.Context, req *actors.GetStateRequest) (*actors.StateResponse, error) {
       return nil, nil
}

func (f *FailingActors) TransactionalStateOperation(ctx context.Context, req *actors.TransactionalRequest) error {
       return nil
}

func (f *FailingActors) GetReminder(ctx context.Context, req *actors.GetReminderRequest) (*actors.Reminder, error) {
       return nil, nil
}

func (f *FailingActors) CreateReminder(ctx context.Context, req *actors.CreateReminderRequest) error {
       return nil
}

func (f *FailingActors) DeleteReminder(ctx context.Context, req *actors.DeleteReminderRequest) error {
       return nil
}

func (f *FailingActors) RenameReminder(ctx context.Context, req *actors.RenameReminderRequest) error {
       return nil
}

func (f *FailingActors) CreateTimer(ctx context.Context, req *actors.CreateTimerRequest) error {
       return nil
}

func (f *FailingActors) DeleteTimer(ctx context.Context, req *actors.DeleteTimerRequest) error {
       return nil
}

func (f *FailingActors) IsActorHosted(ctx context.Context, req *actors.ActorHostedRequest) bool {
       return true
}

func (f *FailingActors) GetActiveActorsCount(ctx context.Context) []actors.ActiveActorsCount {
       return []actors.ActiveActorsCount{}
}
